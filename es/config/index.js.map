{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/config/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Configuration, IAction } from '../'\n\ntype SubType<Base, Condition> = Pick<\n  Base,\n  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]\n>\n\n/*\n  MERGE\n*/\n\nexport function merge<A extends Configuration, B extends Configuration>(\n  configA: A,\n  configB: B\n): A & B\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration\n>(configA: A, configB: B, configC: C): A & B & C\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration,\n  D extends Configuration\n>(configA: A, configB: B, configC: C, configD: D): A & B & C & D\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration,\n  D extends Configuration,\n  E extends Configuration\n>(configA: A, configB: B, configC: C, configD: D, configE: E): A & B & C & D & E\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration,\n  D extends Configuration,\n  E extends Configuration,\n  F extends Configuration\n>(\n  configA: A,\n  configB: B,\n  configC: C,\n  configD: D,\n  configE: E,\n  configF: F\n): A & B & C & D & E & F\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration,\n  D extends Configuration,\n  E extends Configuration,\n  F extends Configuration,\n  G extends Configuration\n>(\n  configA: A,\n  configB: B,\n  configC: C,\n  configD: D,\n  configE: E,\n  configF: F,\n  configG: G\n): A & B & C & D & E & F & G\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration,\n  D extends Configuration,\n  E extends Configuration,\n  F extends Configuration,\n  G extends Configuration,\n  H extends Configuration\n>(\n  configA: A,\n  configB: B,\n  configC: C,\n  configD: D,\n  configE: E,\n  configF: F,\n  configG: G,\n  configH: H\n): A & B & C & D & E & F & G & H\nexport function merge<\n  A extends Configuration,\n  B extends Configuration,\n  C extends Configuration,\n  D extends Configuration,\n  E extends Configuration,\n  F extends Configuration,\n  G extends Configuration,\n  H extends Configuration,\n  I extends Configuration\n>(\n  configA: A,\n  configB: B,\n  configC: C,\n  configD: D,\n  configE: E,\n  configF: F,\n  configG: G,\n  configH: H,\n  configI: I\n): A & B & C & D & E & F & G & H & I\nexport function merge(...configurations: Configuration[]): Configuration {\n  const initializers = configurations.reduce(\n    (aggr, config) =>\n      config.onInitialize ? aggr.concat(config.onInitialize) : aggr,\n    [] as any[]\n  )\n\n  return configurations.reduce(\n    (aggr, config) => {\n      return {\n        onInitialize: aggr.onInitialize,\n        state: {\n          ...aggr.state,\n          ...config.state,\n        },\n        effects: {\n          ...aggr.effects,\n          ...config.effects,\n        },\n        actions: {\n          ...aggr.actions,\n          ...config.actions,\n        },\n      }\n    },\n    {\n      onInitialize: initializers.length\n        ? (context) => Promise.all(initializers.map((cb) => cb(context)))\n        : undefined,\n      state: {},\n      effects: {},\n      actions: {},\n    }\n  )\n}\n\n/*\n  NAMESPACED\n*/\ninterface NamespacedConfiguration {\n  [namespace: string]: {\n    onInitialize?: any\n    state?: {}\n    effects?: {}\n    actions?: {}\n    reactions?: {}\n  }\n}\n\nfunction parseNamespacedConfig(\n  result: { actions: any; effects: any; state: any; initializers: any[] },\n  name: string,\n  config: Configuration\n) {\n  const { actions, effects, onInitialize, state }: Configuration = config\n\n  if (actions) {\n    result.actions[name] = actions\n  }\n  if (effects) {\n    result.effects[name] = effects\n  }\n  if (state) {\n    result.state[name] = state\n  }\n  if (onInitialize) {\n    result.initializers.push(onInitialize)\n  }\n}\n\nexport function namespaced<T extends NamespacedConfiguration>(\n  namespaces: T\n): {\n  onInitialize?: any\n  state: SubType<{ [P in keyof T]: T[P]['state'] }, object>\n  effects: SubType<{ [P in keyof T]: T[P]['effects'] }, object>\n  actions: SubType<{ [P in keyof T]: T[P]['actions'] }, object>\n} {\n  const result: any = {\n    initializers: [],\n    actions: {},\n    effects: {},\n    state: {},\n  }\n\n  Object.keys(namespaces).forEach((name) => {\n    parseNamespacedConfig(result, name, namespaces[name])\n  })\n\n  return Object.assign(\n    {\n      actions: result.actions,\n      effects: result.effects,\n      state: result.state,\n    },\n    result.initializers.length\n      ? {\n          onInitialize: (context) =>\n            Promise.all(result.initializers.map((cb) => cb(context))),\n        }\n      : {}\n  )\n}\n\ninterface LazyConfiguration {\n  [namespace: string]: () => Promise<{\n    onInitialize?: any\n    state?: {}\n    effects?: {}\n    actions?: {}\n    reactions?: {}\n  }>\n}\n\nexport function lazy<T extends LazyConfiguration, B = T>(\n  configurations: T\n): {\n  onInitialize?: any\n  state: SubType<\n    {\n      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>\n        ? U extends { state: any }\n          ? U['state']\n          : never\n        : never\n    },\n    object\n  >\n  effects: SubType<\n    {\n      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>\n        ? U extends { effects: any }\n          ? U['effects']\n          : never\n        : never\n    },\n    object\n  > & {\n    lazy: {\n      loadConfig: (config: keyof T) => Promise<void>\n    }\n  }\n  actions: SubType<\n    {\n      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>\n        ? U extends { actions: any }\n          ? U['actions']\n          : never\n        : never\n    },\n    object\n  > & {\n    lazy: {\n      loadConfig: IAction<any, keyof T>\n    }\n  }\n} {\n  let app\n  return {\n    onInitialize({ value }) {\n      app = value\n    },\n    effects: {\n      lazy: {\n        loadConfig(config) {\n          return app.actions.lazy.loadConfig(config)\n        },\n      },\n    },\n    actions: {\n      lazy: {\n        loadConfig({ value: key, state, ...rest }) {\n          const configToLoad = configurations[key]\n          configToLoad().then((loadedConfig) => {\n            const newConfig = namespaced({\n              [key]: loadedConfig,\n            })\n\n            if (newConfig.state && newConfig.state[key])\n              state[key] = newConfig.state[key]\n            if (newConfig.effects && newConfig.effects[key])\n              app.effects[key] = newConfig.effects[key]\n            if (newConfig.actions && newConfig.actions[key])\n              app.actions[key] = app.getActions(newConfig.actions[key])\n            if (newConfig.onInitialize)\n              newConfig.onInitialize({\n                value: app,\n                state,\n                ...rest,\n              })\n          })\n        },\n      },\n    },\n  } as any\n}\n"]}