{"version":3,"file":"internalTypes.js","sourceRoot":"","sources":["../src/internalTypes.ts"],"names":[],"mappings":";;AA6BA,IAAY,SAcX;AAdD,WAAY,SAAS;IACnB,0CAA6B,CAAA;IAC7B,sCAAyB,CAAA;IACzB,8CAAiC,CAAA;IACjC,0CAA6B,CAAA;IAC7B,8CAAiC,CAAA;IACjC,oCAAuB,CAAA;IACvB,8BAAiB,CAAA;IACjB,gCAAmB,CAAA;IACnB,4CAA+B,CAAA;IAC/B,4CAA+B,CAAA;IAC/B,kDAAqC,CAAA;IACrC,kDAAqC,CAAA;IACrC,8BAAiB,CAAA;AACnB,CAAC,EAdW,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAcpB","sourcesContent":["import { IMutation, IMutationTree } from 'proxy-state-tree'\nimport { Configuration, IAction, IOperator, TStateObject } from './types'\n\nexport type SubType<Base, Condition> = Pick<\n  Base,\n  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]\n>\n\nexport type NestedPartial<T> = T extends Function\n  ? T\n  : Partial<{ [P in keyof T]: NestedPartial<T[P]> }>\n\nexport type Options = {\n  name?: string\n  devtools?: string | boolean\n  logProxies?: boolean\n  testMode?: {\n    effectsCallback: (\n      effect: {\n        effectId: number\n        name: string\n        method: string\n        args: any[]\n      }\n    ) => {}\n    actionCallback: (execution: any) => void\n  }\n}\n\nexport enum EventType {\n  ACTION_START = 'action:start',\n  ACTION_END = 'action:end',\n  OPERATOR_START = 'operator:start',\n  OPERATOR_END = 'operator:end',\n  OPERATOR_ASYNC = 'operator:async',\n  MUTATIONS = 'mutations',\n  EFFECT = 'effect',\n  DERIVED = 'derived',\n  DERIVED_DIRTY = 'derived:dirty',\n  COMPONENT_ADD = 'component:add',\n  COMPONENT_UPDATE = 'component:update',\n  COMPONENT_REMOVE = 'component:remove',\n  GETTER = 'getter',\n}\n\nexport type Execution = {\n  actionId: number\n  executionId: number\n  actionName: string\n  operatorId: number\n  path: string[]\n  emit(event: EventType, value: any): void\n  flush(): {\n    mutations: IMutation[]\n    flushId: number\n  }\n  getMutationTree(): IMutationTree<any>\n}\n\nexport interface Events {\n  [EventType.ACTION_START]: Execution\n  [EventType.ACTION_END]: Execution\n  [EventType.OPERATOR_START]: Execution & {\n    path: string[]\n    type: string\n    name?: string\n  }\n  [EventType.OPERATOR_END]: Execution & {\n    path: string[]\n    isAsync: boolean\n    result: any\n  }\n  [EventType.OPERATOR_ASYNC]: Execution & {\n    path: string[]\n    type: string\n    name: string\n  }\n  [EventType.MUTATIONS]: Execution & {\n    mutations: IMutation[]\n  }\n  [EventType.DERIVED]: {\n    path: string\n    paths: string[]\n    updateCount: number\n    value: any\n  }\n  [EventType.DERIVED_DIRTY]: {\n    path: string\n    flushId: number\n  }\n  [EventType.EFFECT]: Execution & {\n    result: any\n    name: string\n    method: string\n    args: any[]\n    isPending: boolean\n    error: string\n    effectId: number\n  }\n  [EventType.GETTER]: {\n    path: string\n    value: any\n  }\n  [EventType.COMPONENT_ADD]: {\n    componentId: number | string\n    componentInstanceId: number\n    name: string\n    paths: string[]\n  }\n  [EventType.COMPONENT_UPDATE]: {\n    componentId: number | string\n    componentInstanceId: number\n    name: string\n    paths: string[]\n    flushId?: number\n  }\n  [EventType.COMPONENT_REMOVE]: {\n    componentId: number | string\n    componentInstanceId: number\n    name: string\n  }\n}\n\n// ============= PRIVATE TYPES FOR APP\n\nexport type TBaseContext<Config extends Configuration> = {\n  state: ResolveState<Config['state']>\n  actions: ResolveActions<Config['actions']>\n  effects: Config['effects']\n  execution: any\n}\n\ntype Derived = (parent: any, config: any) => any\n\nexport type ResolveState<State extends TStateObject> = State extends undefined\n  ? {}\n  : {\n      [P in keyof State]: State[P] extends Derived\n        ? ReturnType<State[P]>\n        : State[P] extends Array<any>\n        ? State[P]\n        : State[P] extends TStateObject\n        ? ResolveState<State[P]>\n        : State[P]\n    }\n\ntype TActionValue<T> = T extends (a1: infer TContext) => any\n  ? (TContext extends { value: infer TValue } ? TValue : never)\n  : never\n\ntype TOperationValue<T> = T extends (\n  arg1: any,\n  arg2: infer TContext,\n  arg3: any\n) => any\n  ? (TContext extends { value: infer TValue } ? TValue : never)\n  : never\n\ntype NestedActions =\n  | {\n      [key: string]:\n        | IAction<any, any>\n        | IOperator<any, any, any>\n        | NestedActions\n    }\n  | undefined\n\nexport type ResolveActions<\n  Actions extends NestedActions\n> = Actions extends undefined\n  ? {}\n  : {\n      [T in keyof Actions]: Actions[T] extends IAction<any, any>\n        ? TActionValue<Actions[T]> extends void\n          ? () => Promise<void>\n          : (value: TActionValue<Actions[T]>) => Promise<void>\n        : Actions[T] extends IOperator<any, any, any>\n        ? TOperationValue<Actions[T]> extends void\n          ? () => Promise<void>\n          : (value: TOperationValue<Actions[T]>) => Promise<void>\n        : Actions[T] extends NestedActions\n        ? ResolveActions<Actions[T]>\n        : never\n    }\n\ntype NestedMockActions =\n  | {\n      [key: string]:\n        | IAction<any, any>\n        | IOperator<any, any, any>\n        | NestedMockActions\n    }\n  | undefined\n\ntype MockResult = IMutation[]\n\nexport type ResolveMockActions<\n  Actions extends NestedMockActions\n> = Actions extends undefined\n  ? {}\n  : {\n      [T in keyof Actions]: Actions[T] extends IAction<any, any>\n        ? TActionValue<Actions[T]> extends void\n          ? () => Promise<MockResult>\n          : (value: TActionValue<Actions[T]>) => Promise<MockResult>\n        : Actions[T] extends IOperator<any, any, any>\n        ? TOperationValue<Actions[T]> extends void\n          ? () => Promise<MockResult>\n          : (value: TOperationValue<Actions[T]>) => Promise<MockResult>\n        : Actions[T] extends NestedMockActions\n        ? ResolveMockActions<Actions[T]>\n        : never\n    }\n"]}